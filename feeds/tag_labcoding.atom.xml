<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Liang2's blog</title><link href="//blog.liang2.tw/" rel="alternate"></link><link href="//blog.liang2.tw/feeds/tag_labcoding.atom.xml" rel="self"></link><id>//blog.liang2.tw/</id><updated>2016-01-21T23:30:00+08:00</updated><entry><title>Coding 初學指南附錄 - Bioinfo Practices using Python</title><link href="//blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/" rel="alternate"></link><updated>2016-01-21T23:30:00+08:00</updated><author><name>Liang2</name></author><id>tag:blog.liang2.tw,2016-01-21:posts/2016/01/lab-coding-appendix-bioinfo-python/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;I want to play a&amp;nbsp;game.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We are going to walk through a series of practice created by &lt;a href="http://rosalind.info/problems/"&gt;Rosalind Team&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Once you register an account at Rosalind, you can use their judging system to work through all problems. However, in this case you cannot arbitrarily skip easy levels and it sucks. So I&amp;rsquo;m not going to force you using the system. Luckily, in each problem one set of example data and expected output is given, which can be used for checking our&amp;nbsp;answer.&lt;/p&gt;
&lt;p&gt;Note: Their code assumes Python 2 but everything I mention here is Python&amp;nbsp;3.&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#python-basics"&gt;Python&amp;nbsp;Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bininfo-first-try"&gt;Bininfo First Try&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#q-dna-counting-dna-nucleotides"&gt;Q &lt;span class="caps"&gt;DNA&lt;/span&gt;: Counting &lt;span class="caps"&gt;DNA&lt;/span&gt;&amp;nbsp;Nucleotides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#q-revc-the-secondary-and-tertiary-structures-of-dna"&gt;Q &lt;span class="caps"&gt;REVC&lt;/span&gt;: The Secondary and Tertiary Structures of &lt;span class="caps"&gt;DNA&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#q-gc-computing-gc-content"&gt;Q: &lt;span class="caps"&gt;GC&lt;/span&gt;: Computing &lt;span class="caps"&gt;GC&lt;/span&gt; Content&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#workthrough"&gt;Workthrough&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#q-next"&gt;Q:&amp;nbsp;(next?)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="python-basics"&gt;Python&amp;nbsp;Basics&lt;/h2&gt;
&lt;p&gt;Do their &lt;a href="http://rosalind.info/problems/list-view/?location=python-village"&gt;Python Village&lt;/a&gt; problem sets. If any topic you don&amp;rsquo;t know, go read your Python&amp;nbsp;reference.&lt;/p&gt;
&lt;p&gt;Should be very&amp;nbsp;trivial.&lt;/p&gt;
&lt;h2 id="bininfo-first-try"&gt;Bininfo First&amp;nbsp;Try&lt;/h2&gt;
&lt;h3 id="q-dna-counting-dna-nucleotides"&gt;Q &lt;span class="caps"&gt;DNA&lt;/span&gt;: Counting &lt;span class="caps"&gt;DNA&lt;/span&gt;&amp;nbsp;Nucleotides&lt;/h3&gt;
&lt;p&gt;Link: &lt;a href="http://rosalind.info/problems/dna/"&gt;http://rosalind.info/problems/dna/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: use &lt;a href="https://docs.python.org/3/library/collections.html#collections.Counter"&gt;collections.Counter&lt;/a&gt; provided by Python&amp;rsquo;s&amp;nbsp;stdlib&lt;/li&gt;
&lt;li&gt;More Hint: use &lt;code&gt;' '.join&lt;/code&gt; and list comprehension to output the&amp;nbsp;answer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="q-revc-the-secondary-and-tertiary-structures-of-dna"&gt;Q &lt;span class="caps"&gt;REVC&lt;/span&gt;: The Secondary and Tertiary Structures of &lt;span class="caps"&gt;DNA&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Link: &lt;a href="http://rosalind.info/problems/revc/"&gt;http://rosalind.info/problems/revc/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: &lt;a href="https://docs.python.org/3/library/functions.html#reversed"&gt;reversed&lt;/a&gt; for any sequence object and a dict for nucleotide code&amp;nbsp;mapping &lt;/li&gt;
&lt;li&gt;More Hint: done in a list&amp;nbsp;comprehension&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="q-gc-computing-gc-content"&gt;Q: &lt;span class="caps"&gt;GC&lt;/span&gt;: Computing &lt;span class="caps"&gt;GC&lt;/span&gt;&amp;nbsp;Content&lt;/h3&gt;
&lt;p&gt;Link: &lt;a href="http://rosalind.info/problems/gc/"&gt;http://rosalind.info/problems/gc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This is the first complicated problem that some abstraction should help you come up the solution. Try write some re-usable code blocks, for example, function calls and class&amp;nbsp;definitions.&lt;/p&gt;
&lt;p&gt;Don&amp;rsquo;t worry about the computation&amp;nbsp;complexity&lt;/p&gt;
&lt;h4 id="workthrough"&gt;Workthrough&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;You should implement by yourself before looking my solution. Also I didn&amp;rsquo;t see their official solution so my solution can differ a lot from&amp;nbsp;theirs.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Intuitively, we need to implement a &lt;span class="caps"&gt;FASTA&lt;/span&gt; file parser. &lt;span class="caps"&gt;FASTA&lt;/span&gt; contains a series of sequence reads with unique &lt;span class="caps"&gt;ID&lt;/span&gt;. From a object-oriented viewpoint, we create classes &lt;code&gt;Read&lt;/code&gt; for reads and &lt;code&gt;Fasta&lt;/code&gt; for fasta&amp;nbsp;files.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Read&lt;/code&gt; is easy to design and&amp;nbsp;understand,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since we need to compute their &lt;span class="caps"&gt;GC&lt;/span&gt; content, add a method for &lt;code&gt;Read&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# ... skipped&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Compute the GC content (in %) of the read.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="c"&gt;# put the logic here (think of problem Q DNA)&lt;/span&gt;
        &lt;span class="n"&gt;gc_percent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;gc_percent&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then we have to implement the &lt;span class="caps"&gt;FASTA&lt;/span&gt; parser, which reads all read entries and converts them through &lt;code&gt;Read&lt;/code&gt;. In real world we are dealing with &lt;code&gt;myfasta.fa&lt;/code&gt;-like files, but here the input is&amp;nbsp;string.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Fasta&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;raw_str&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Parse a FASTA formated string.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raw_str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;raw_str&lt;/span&gt;
        &lt;span class="c"&gt;# convert string into structured reads.&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reads&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Parse the string and yield read in Read class.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="c"&gt;# though we have no idea right now, the code structure&lt;/span&gt;
        &lt;span class="c"&gt;# should be something like the following.&lt;/span&gt;
        &lt;span class="n"&gt;raw_lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;raw_str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;splitlines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;raw_lines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here I use &lt;code&gt;yield Read(...)&lt;/code&gt;, which may be unfamiliar for Python beginners. It turns &lt;code&gt;parse(self)&lt;/code&gt; function as a generator. Generator makes you focus on the incoming data. Once data is parsed and converted, the result is immediated thrown out by &lt;code&gt;yield&lt;/code&gt;. We don&amp;rsquo;t care about how to collect all the results. In our case, we catch all the results into a list by &lt;code&gt;list(...)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So how should we read &lt;span class="caps"&gt;FASTA&lt;/span&gt; file? A simple rule in this case is that every read consists by two continuous row. Also, the first row will always be the first read&amp;nbsp;id.&lt;/p&gt;
&lt;p&gt;All we need is read two lines at the same time. Here &lt;a href="https://docs.python.org/3/library/functions.html#zip"&gt;a Pythonic idiom&lt;/a&gt; is introduced. The following code read two non-overlapping&amp;nbsp;lines,&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;first_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second_line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw_lines&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;first_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;second_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By &lt;code&gt;zip(*[iter(s)]*n)&lt;/code&gt; magic, we are very close to implement a full parser. You could find a lot of &lt;a href="http://stackoverflow.com/a/2233247"&gt;explanations&lt;/a&gt; for this&amp;nbsp;magic. &lt;/p&gt;
&lt;p&gt;Read id line percedes with a &lt;code&gt;&amp;gt;&lt;/code&gt; sign, so we could use something like &lt;code&gt;first_line[1:]&lt;/code&gt; or &lt;code&gt;first_line[len('&amp;gt;'):]&lt;/code&gt; for&amp;nbsp;explicity.&lt;/p&gt;
&lt;p&gt;Then sorting the &lt;span class="caps"&gt;GC&lt;/span&gt;% of reads in a &lt;span class="caps"&gt;FASTA&lt;/span&gt; file is&amp;nbsp;easy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;fasta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Fasta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;...&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sorted_reads&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fasta&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reads&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  &lt;span class="c"&gt;# note 1&lt;/span&gt;
&lt;span class="n"&gt;top_gc_read&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sorted_reads&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c"&gt;# note 2&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;&amp;gt;{0:s}&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;{1:.6f}&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;# note 3, 4&lt;/span&gt;
    &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top_gc_read&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;top_gc_read&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gc&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code above completes the following&amp;nbsp;steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sorted(list, key=key_func)&lt;/code&gt; sorts the list based on the return value of key_func applied to each&amp;nbsp;element.&lt;/li&gt;
&lt;li&gt;or &lt;code&gt;top_gc_read = sorted(..., reversed=True)[0]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;two string with no operands in between will be joint automatically. In this case it is exactly &lt;code&gt;&amp;gt;{0:s}\n{1:.6f}&lt;/code&gt;. This is useful to tidy a super long&amp;nbsp;string.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'...'.format()&lt;/code&gt; fills the string with given values. See &lt;a href="https://docs.python.org/3/library/string.html#formatspec"&gt;doc&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In real case &lt;span class="caps"&gt;FASTA&lt;/span&gt; can span across multiple lines, also likely the file we parse is broken. How could we modify this parser to handle these&amp;nbsp;situations?&lt;/p&gt;
&lt;h3 id="q-next"&gt;Q:&amp;nbsp;(next?)&lt;/h3&gt;
&lt;p&gt;I&amp;rsquo;m super tired now so I&amp;rsquo;ll leave the rest for you. Try those problems within yellow correct ratio&amp;nbsp;range.&lt;/p&gt;</summary><category term="en"></category><category term="labcoding"></category><category term="python"></category></entry><entry><title>Coding 初學指南附錄 - OSX 開發環境</title><link href="//blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/" rel="alternate"></link><updated>2016-01-21T23:00:00+08:00</updated><author><name>Liang2</name></author><id>tag:blog.liang2.tw,2016-01-21:posts/2016/01/lab-coding-appendix-osx-env/</id><summary type="html">&lt;p&gt;以下的設定都蠻主觀的，見人見智。總之我把我的環境分享出來。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#terminal"&gt;Terminal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#homebrew-git-and-python"&gt;Homebrew, Git and&amp;nbsp;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#text-editors"&gt;Text&amp;nbsp;Editors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#terminal-multiplexers"&gt;Terminal&amp;nbsp;Multiplexers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-gui"&gt;Git &lt;span class="caps"&gt;GUI&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#documentation-searcher"&gt;Documentation&amp;nbsp;Searcher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#misc"&gt;Misc.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="terminal"&gt;Terminal&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;OSX&lt;/span&gt; 系統有內建一個 &lt;code&gt;Terminals.app&lt;/code&gt; 能像在 Linux 上一樣使用。他其實使用上沒什麼問題，不過想要調顏色，有更多自定功能的話，許多人會安裝 &lt;a href="http://iterm2.com/"&gt;iTerm2&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="homebrew-git-and-python"&gt;Homebrew, Git and&amp;nbsp;Python&lt;/h2&gt;
&lt;p&gt;&lt;span class="caps"&gt;OSX&lt;/span&gt; 上官方沒有一個管理套件的工具，所以社群自行開發了一個叫做 Homebrew。你可以按照&lt;a href="http://djangogirlstaipei.herokuapp.com/tutorials/installation/"&gt;這篇教學&lt;/a&gt;安裝&amp;nbsp;Homebrew。&lt;/p&gt;
&lt;p&gt;裝好了之後你可以以下指令去看它該怎麼操作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;brew --help
&lt;span class="nv"&gt;$ &lt;/span&gt;man brew    &lt;span class="c"&gt;# for full documentation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class="caps"&gt;OSX&lt;/span&gt; 雖然內建有 git 與 python，但我們可以用 homebrew&amp;nbsp;安裝比較標準（新）的版本，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;brew install git python3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 homebrew 有問題可以用 &lt;code&gt;brew doctor&lt;/code&gt; 來檢測。把錯誤訊息問 google&amp;nbsp;通常就能找到解決方式。&lt;/p&gt;
&lt;h2 id="text-editors"&gt;Text&amp;nbsp;Editors&lt;/h2&gt;
&lt;p&gt;我最常用的是 Vim。&lt;span class="caps"&gt;OSX&lt;/span&gt; 有內建，但也可以用 homebrew&amp;nbsp;安裝。&lt;/p&gt;
&lt;p&gt;除了 console based 的 Vim，&lt;span class="caps"&gt;OSX&lt;/span&gt; 上也有像 gVim 的 MacVim。一樣能用 homebrew&amp;nbsp;安裝。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;brew info macvim  &lt;span class="c"&gt;# 看 MacVim 在安裝有什麼選項可以調整&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;brew install macvim --override-system-vim --custom-icons
&lt;span class="nv"&gt;$ &lt;/span&gt;brew linkapps macvim
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 Macvim 的時候除了 vim 之外，也可以呼叫 &lt;code&gt;mvim&lt;/code&gt; 打開&amp;nbsp;MacVim。&lt;/p&gt;
&lt;h2 id="terminal-multiplexers"&gt;Terminal&amp;nbsp;Multiplexers&lt;/h2&gt;
&lt;p&gt;你有可能有聽過 screen 或者 tmux。前者在 osx 上有內建但版本很舊，在顯示顏色上會有問題，因此可以透過 homebrew 再安裝新的。但因為 screen 跟系統提供的重覆到了，所以預設不在 homebrew 的 repo 中，要先新增 repo&amp;nbsp;清單：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;brew tap homebrew/dupes
brew install screen tmux
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="git-gui"&gt;Git &lt;span class="caps"&gt;GUI&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;初學 Git 可能會不熟那些指令、常常不知道自己在 git log 哪個位置。這時候有個圖形化的工具會更方便了解。Git 有內建一個&amp;nbsp;gitk，但比較陽春。&lt;/p&gt;
&lt;p&gt;在 &lt;span class="caps"&gt;OSX&lt;/span&gt; 上可以考慮用 &lt;a href="http://www.sourcetreeapp.com/"&gt;SourceTree&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="documentation-searcher"&gt;Documentation&amp;nbsp;Searcher&lt;/h2&gt;
&lt;p&gt;要一直查 Python 官網有時候還蠻麻煩的，未來學了 &lt;span class="caps"&gt;HTML&lt;/span&gt; &lt;span class="caps"&gt;CSS&lt;/span&gt; 等等不同語言或各種 Python 套件，要查個東西會很費時。所以有人開發了一個離線的 documentation 查詢器叫做 &lt;a href="http://kapeli.com/dash"&gt;Dash&lt;/a&gt;。他要錢但有免費版，似乎是會一直跳提示訊息。&lt;/p&gt;
&lt;h2 id="misc"&gt;Misc.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.alfredapp.com/"&gt;Alfred App&lt;/a&gt;：一個延伸版的 Spotlight，查應用程式很快速，同時也可以跟 Dash 整合讓查 doc&amp;nbsp;更方便。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://macdown.uranusjr.com/"&gt;Macdown&lt;/a&gt;：&lt;span class="caps"&gt;OSX&lt;/span&gt; 上的 markdown&amp;nbsp;編輯器。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="zh"></category><category term="labcoding"></category></entry><entry><title>Coding 初學指南－Python</title><link href="//blog.liang2.tw/posts/2016/01/lab-coding-python/" rel="alternate"></link><updated>2016-01-21T22:50:00+08:00</updated><author><name>Liang2</name></author><id>tag:blog.liang2.tw,2016-01-21:posts/2016/01/lab-coding-python/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;Python&amp;nbsp;是一種物件導向、直譯式的電腦程式語言，具有近二十年的發展歷史。它包含了一組功能完備的標準庫，能夠輕鬆完成很多常見的任務。&lt;/p&gt;
&lt;p&gt;(From &lt;a href="https://zh.wikipedia.org/wiki/Python"&gt;Wikipedia&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;選擇 Python 作為第一個深入學習的語言有很多好處。他的語法跟英文相似，比起其他語言經常用到 &lt;code&gt;;{}()&lt;/code&gt; 來控制語法不同的段落，Python&amp;nbsp;主要用的是空白與縮排。&lt;/p&gt;
&lt;p&gt;Python 能用互動式的方式（read–eval–print loop, &lt;span class="caps"&gt;REPL&lt;/span&gt;）來操作，以邊試邊做的方法來開發很適合初學者。&lt;/p&gt;
&lt;p&gt;內建的標準庫（standard library）功能很豐富，在網路、文字處理、檔案處理、甚至 &lt;span class="caps"&gt;GUI&lt;/span&gt; 介面都能用它完成。除此之外，它的第三方套件也很多，在 Linux 上很好安裝，這樣幾乎能用 Python&amp;nbsp;完成各種事情。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;聽說系列&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#python"&gt;聽說 Python&amp;nbsp;跑很慢，是不是不能用來計算/分析/大檔案？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python-2-python-3"&gt;Python 2 還是 Python&amp;nbsp;3，聽我朋友說…比較好？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introducing-python-python"&gt;Introducing Python（精通&amp;nbsp;Python）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python_1"&gt;Python&amp;nbsp;程式設計入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python-3-2ed"&gt;精通 Python 3 程式設計&amp;nbsp;2ed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python_2"&gt;Python&amp;nbsp;官網&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#learning-python-5ed"&gt;Learning Python&amp;nbsp;5ed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python-cookbook-3edpython-3ed"&gt;Python Cookbook 3ed（Python 的錦囊妙計&amp;nbsp;3ed）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#python_3"&gt;深入淺出&amp;nbsp;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#moocs"&gt;MOOCs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;聽說系列&lt;/h2&gt;
&lt;p&gt;（需要接觸過 Python&amp;nbsp;之後才能理解）&lt;/p&gt;
&lt;h3 id="python"&gt;聽說 Python&amp;nbsp;跑很慢，是不是不能用來計算/分析/大檔案？&lt;/h3&gt;
&lt;p&gt;Python 的確執行效率比編譯式的語言差（例：C/C++、Java），但這很可能不是你程式跑得慢的主因，所以也不代表 Python&amp;nbsp;不能處理計算量高的工作。&lt;/p&gt;
&lt;p&gt;碰到程式跑得比想像中慢的時候，有幾個步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;到底是哪幾行程式跑得慢？&lt;/li&gt;
&lt;li&gt;這是最佳的演算法嗎？&lt;/li&gt;
&lt;li&gt;這是最有效率的 Python&amp;nbsp;語法嗎？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果用到了最後一步情況還是沒有改善的話，就可以開始把那些部份用其他語言改寫，例如：C。Python 能很容易跟 C 語言的結合。而且常見的 C 語言加速，其實都有 Python 套件能支援了，例如 Numpy，所以大部份的時間，都能在不使用 Python&amp;nbsp;以外的語言完成高量計算。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我在實習時候，也常碰到需要優化的問題。用 Python 我能很輕鬆（一天內）把工作分配到 4 台主機 64 cores 上跑，也許方法不有效率，但比起我花幾天把 Python 改寫成 C/C++，實作更精密有效的算法（還要是 multithread），仔細處理可能的 corner case，平行化之後本來三四天的計算時間我 2&amp;nbsp;個小時就能收工。&lt;/p&gt;
&lt;p&gt;更重要的是，這個實驗就只跑個兩次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比起計算時間，開發時間對工程師而言是更加寶貴的。尤其在實驗室，最關心的是這個方法行不行得通，程式跑得慢有很多解決的方式，例如平行化。重點在解決問題，需要用多一點的資源其實不是很重要。&lt;/p&gt;
&lt;p&gt;如果問我 Python 還是 Matlab 比較快？這邊有正經的 &lt;a href="http://www.pyzo.org/python_vs_matlab.html"&gt;Python vs Matlab&lt;/a&gt;。一開始選 Python 慢的話有&lt;a href="http://wiki.scipy.org/PerformancePython"&gt;很多條路可以走&lt;/a&gt;，但 Matlab 呢？&amp;nbsp;meh&lt;/p&gt;
&lt;p&gt;所以 Python 跑得快不快？它單打獨鬥有極限，但它有很多快樂夥伴。O&amp;rsquo;Reilly 有本 &lt;a href="http://shop.oreilly.com/product/0636920028963.do"&gt;High Performance Python&lt;/a&gt;&amp;nbsp;值得一看。&lt;/p&gt;
&lt;h3 id="python-2-python-3"&gt;Python 2 還是 Python&amp;nbsp;3，聽我朋友說…比較好？&lt;/h3&gt;
&lt;p&gt;隨著時間流逝，每過一天我都可以更確信的說&lt;strong&gt;「請學 Python 3」&lt;/strong&gt;。現在有在用 Python 2 多半也是用 2.7 版本，要把 3.3+ 的程式碼改回 2.7&amp;nbsp;也不難。&lt;/p&gt;
&lt;h2 id="_2"&gt;相關資源&lt;/h2&gt;
&lt;p&gt;連同前幾章，如果你要在自己電腦上設定 Python 開發環境，可以參考 &lt;a href="http://djangogirlstaipei.herokuapp.com/tutorials/"&gt;Djang Girls Taipei Tutorial&lt;/a&gt;。另外，&lt;a href="http://wiki.python.org.tw/Python/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8%E5%B0%B1%E4%B8%8A%E6%89%8B"&gt;Python Taiwan Wiki&lt;/a&gt; 有更完整的 Python&amp;nbsp;學習資源列表。&lt;/p&gt;
&lt;h3 id="introducing-python-python"&gt;Introducing Python（精通&amp;nbsp;Python）&lt;/h3&gt;
&lt;p&gt;O&amp;rsquo;Reilly Python 系列的書都寫得很好。這本是比較新出的，好處是它針對初學者，而且比較薄能在短時間看完。建議閱讀 Chp1 到 Chp7 ，以及 Chp8 File Input/Output&amp;nbsp;部份。&lt;/p&gt;
&lt;p&gt;可以在 O&amp;rsquo;Reilly 的線上商店買電子版拿到 &lt;span class="caps"&gt;PDF&lt;/span&gt; 與 Kindle&amp;nbsp;版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/0636920028659.do"&gt;英文書&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9863477311?item_id=1007464"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="python_1"&gt;Python&amp;nbsp;程式設計入門&lt;/h3&gt;
&lt;p&gt;2015 四月由&lt;a href="http://yehnan.blogspot.tw/2015/03/python_30.html"&gt;葉難&lt;/a&gt;出的中文書，針對初學者，並有列出 Python 2.7、3.3、3.4&amp;nbsp;不同版本間的差異。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9864340050"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="python-3-2ed"&gt;精通 Python 3 程式設計&amp;nbsp;2ed&lt;/h3&gt;
&lt;p&gt;另一本 Python&amp;nbsp;中文入門書，比深入淺出難一點但比較像常規的教科書。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9862760702"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="python_2"&gt;Python&amp;nbsp;官網&lt;/h3&gt;
&lt;p&gt;Python 的官網一方面是用來查語言特性之外，還能用來學習怎麼使用 stdlib。除外還有一個簡潔的&amp;nbsp;Tutorial，可以供初學者參考，適合有學過其他語言的人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Keep this under your&amp;nbsp;pillow.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/"&gt;連結&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pythondoc.com/"&gt;簡中翻譯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;繁中翻譯&lt;a href="https://github.com/python-doc-tw/python-doc-tw"&gt;請拭目以待&lt;/a&gt;&amp;nbsp;:)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="learning-python-5ed"&gt;Learning Python&amp;nbsp;5ed&lt;/h3&gt;
&lt;p&gt;雖然名稱看起來很像是 Python 的入門書，但它的篇幅已經來到 1200 頁，實在無法推薦給初學者。但它把 Python 語言特性說的很清楚，同時考慮到 Python 2 和 3&amp;nbsp;版本。&lt;/p&gt;
&lt;p&gt;我當初看的是這一本 3ed 中文版（現已絕版），那時還沒有考慮 Python&amp;nbsp;3。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/0636920028154.do"&gt;英文書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="python-cookbook-3edpython-3ed"&gt;Python Cookbook 3ed（Python 的錦囊妙計&amp;nbsp;3ed）&lt;/h3&gt;
&lt;p&gt;這本不是入門書但很適合深入了解 Python，並讓自己的程式碼寫得更 &lt;strong&gt;Pythonic&lt;/strong&gt;。裡面介紹了很多寫法慣例 idioms，同時也有中文版。非常值得在未來比較懂 Python&amp;nbsp;時買來看。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/0636920027072.do"&gt;英文書&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9863470686"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="python_3"&gt;深入淺出&amp;nbsp;Python&lt;/h3&gt;
&lt;p&gt;O&amp;rsquo;Reilly Head First&amp;nbsp;系列都是給初學者的書，這本有中文翻譯本，內容圖文並茂活潑。不過不是每個人都喜歡這種嘻嘻哈哈的介紹方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9862763485"&gt;中文實體書&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="moocs"&gt;MOOCs&lt;/h3&gt;
&lt;p&gt;很多人都有試過的線上課程，可能有中文字幕。缺點教的是 Python 2.7。而且我試了幾堂的經驗，並不是教授 idiomatic Python，也就是裡面教的寫法不一定是 Python&amp;nbsp;使用者平常使用並推薦的語法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Codecademy Python Track &lt;a href="http://www.codecademy.com/en/tracks/python"&gt;http://www.codecademy.com/en/tracks/python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Coursera: An Introduction to Interactive Programming in Python &lt;a href="https://www.coursera.org/course/interactivepython"&gt;https://www.coursera.org/course/interactivepython&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;學習目標&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;打開自己 Linux 裡的 Python3，跟著學習用的參考資料動手操作。用 &lt;span class="caps"&gt;REPL&lt;/span&gt; 以及運行腳本兩種方法來執行 Python&amp;nbsp;程式。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;學習使用 pip 和 pyvenv (virtualenv) 來管理 Python&amp;nbsp;套件與環境。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: Python 官網是你的好夥伴。你可以在&lt;a href="https://docs.python.org/3/installing/"&gt;這裡&lt;/a&gt;和&lt;a href="https://docs.python.org/3/using/scripts.html#scripts-pyvenv"&gt;這裡&lt;/a&gt;找到兩者的教學。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://rg3.github.io/youtube-dl/"&gt;youtube-dl&lt;/a&gt; 是一個用來下載 Youtube、Crunchyroll 等各大影音串流網站影片的工具。除了用 Linux 的套件管理工具安裝它，它其實是個用 Python 寫成的套件。為了避免跟 Linux 系統環境相衝，請開一個 Python 虛擬環境，並在裡面用 pip&amp;nbsp;安裝它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Note: youtube-dl 除了單純做下載串流檔之外，還支援轉檔、封裝、後製等影像處理，這需要 libav 或 ffmpeg 任一影像處理套件。在 Debian 系列的 Linux 上 libav&amp;nbsp;會好裝一點。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 Python 解決一些實驗室會碰到的 Bioinfo 問題。有個網站 Rosalind 出了一系列的題目，我選了一些讓各位練習，請參考&lt;a href="#file-a1_python_bioinfo-md"&gt;附錄 1&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="zh"></category><category term="labcoding"></category><category term="python"></category></entry><entry><title>Coding 初學指南－版本控制</title><link href="//blog.liang2.tw/posts/2016/01/lab-coding-version-control/" rel="alternate"></link><updated>2016-01-21T22:40:00+08:00</updated><author><name>Liang2</name></author><id>tag:blog.liang2.tw,2016-01-21:posts/2016/01/lab-coding-version-control/</id><summary type="html">&lt;p&gt;所謂的版本控制就跟玩遊戲一樣可以存取「進度點」，破關前都會保存進度，這樣破關失敗的時候可以還成到保存進度的狀態，再重新打怪。版本控制用在管理程式碼時，就方便讓自己在把 code&amp;nbsp;搞炸掉的時候，還能回到先前有保存的狀態。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id="_1"&gt;為什麼使用版本控制？&lt;/h3&gt;
&lt;p&gt;在軟體開發的過程中，程式碼每天不斷地產出，過程中會發生以下情況：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;檔案被別人或自己覆蓋，甚至遺失&lt;/li&gt;
&lt;li&gt;想復原前幾天寫的版本&lt;/li&gt;
&lt;li&gt;想知道跟昨天寫的差在哪裡？&lt;/li&gt;
&lt;li&gt;是誰改了這段程式碼，為什麼&amp;nbsp;？&lt;/li&gt;
&lt;li&gt;軟體發行，需要分成維護版跟開發版&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，我們希望有一種機制，能夠幫助我們：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以隨時復原修改，回到之前的版本&lt;/li&gt;
&lt;li&gt;多人協作時，不會把別人的東西蓋掉&lt;/li&gt;
&lt;li&gt;保留修改歷史記錄，以供查詢&lt;/li&gt;
&lt;li&gt;軟體發行時，可以方便管理不同版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(From: &lt;a href="http://dylandy.github.io/Easy-Git-Tutorial/"&gt;Git 教學研究站&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能做到版本控制的工具有很多，但目前主流就是&amp;nbsp;Git。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;為什麼使用版本控制？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-version-control"&gt;Git (Version Control)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;操作建議&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#commit-style"&gt;Commit&amp;nbsp;Style&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;常見問題&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#conflict"&gt;Conflict&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#push-fail"&gt;Push&amp;nbsp;fail&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#code-school-try-git"&gt;Code School - Try&amp;nbsp;Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git"&gt;Git&amp;nbsp;教學研究站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code-school-git-real"&gt;Code School - Git&amp;nbsp;Real&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#learn-git-branching"&gt;Learn Git&amp;nbsp;Branching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#git-tutorial-by-atlassian"&gt;Git Tutorial by&amp;nbsp;Atlassian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id="git-version-control"&gt;Git (Version&amp;nbsp;Control)&lt;/h1&gt;
&lt;p&gt;Git&amp;nbsp;是一個版本控制的工具。&lt;/p&gt;
&lt;p&gt;Git 會在你的專案（repo）目錄&lt;sup id="fnref:註1"&gt;&lt;a class="footnote-ref" href="#fn:註1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;底下建一個 &lt;code&gt;.git&lt;/code&gt; 的資料夾來管理這些「進度點」，而不會去動專案其他路徑裡的東西。&lt;/p&gt;
&lt;p&gt;這些進度點可以傳到 server 上，別人下載下來的時候就可以除了得到現在的 code&amp;nbsp;以外，還能看到過去開發的記錄；而別人上傳了他的更新進度點之後，你抓下來就可以得到他更改的進度。這個就是「同步」的概念，多人之間能彼此共享、更新彼此開發的成果。&lt;/p&gt;
&lt;p&gt;能夠處理 Git 同步操作的伺服器就叫做 git server。&lt;a href="https://github.com/"&gt;Github&lt;/a&gt; 就是一間公司提供免費的 git server 讓大家同步公開的 Git 專案。很多 Linux 的工具都使用 git 來讓大家合作開發，也有不少工具已經把 git server 轉到了 Github 上面。所以非常多人在用，因此建議大家不妨申請一個 GitHub&amp;nbsp;帳號。&lt;/p&gt;
&lt;p&gt;Git 雖然最常用來管理程式碼，但它其實可以有效地管理任何純文字的檔案，也可以把 binary  檔案加到 repo&amp;nbsp;中。&lt;/p&gt;
&lt;p&gt;（可能需要有一些 git&amp;nbsp;操作經驗才能了解以下的術語）&lt;/p&gt;
&lt;h2 id="_2"&gt;操作建議&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;建立多而小的進度點&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每完成一系列的更動，就趕快 add 和&amp;nbsp;commit。一開始會煩，但這是好習慣。&lt;/p&gt;
&lt;p&gt;日後更了解 git 操作的時候，會學到一些進階的指令（如 &lt;code&gt;git rebase -i&lt;/code&gt;）就能把多個 commit 合成為一個。但要拆開一個大的 commit&amp;nbsp;會比較複雜。&lt;/p&gt;
&lt;h3 id="commit-style"&gt;Commit&amp;nbsp;Style&lt;/h3&gt;
&lt;p&gt;常見的 commit message&amp;nbsp;大概會是一行文。如果這個更動需要說明，那就建議按照下面的格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行少於 50&amp;nbsp;個字元&lt;/li&gt;
&lt;li&gt;第二行留空&lt;/li&gt;
&lt;li&gt;第三行以後格式隨意，但單行不超過 75&amp;nbsp;個字元&lt;/li&gt;
&lt;li&gt;善用條列式說明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是範例（From &lt;a href="http://git-scm.com/book/ch5-2.html"&gt;Git Book&lt;/a&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to
about 72 characters or so.  In some contexts, the first
line is treated as the subject of an email and the rest of
the text as the body.  The blank line separating the
summary from the body is critical (unless you omit the body
entirely); tools like rebase can get confused if you run
the two together.

Further paragraphs come after blank lines.

  - Bullet points are okay, too

  - Typically a hyphen or asterisk is used for the bullet,
    preceded by a single space, with blank lines in
    between, but conventions vary here
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ps 你可以找到很多有趣的 commit message。例如：&lt;a href="http://www.commitlogsfromlastnight.com/"&gt;抱怨&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="_3"&gt;常見問題&lt;/h2&gt;
&lt;h4 id="conflict"&gt;Conflict&lt;/h4&gt;
&lt;p&gt;當單機只有在一個 branch 上開發的時候，很難有 conflict 的問題。但碰到多人共同開發，或把多條 branch merge 在一起時就會有&amp;nbsp;conflict。&lt;/p&gt;
&lt;p&gt;Conflict 的發生，最常見的就是兩個人各自修改了同一個檔案相近位置的內容。這使得 git&amp;nbsp;在把兩個人的更動融合在一起的時候，會不知道到底要用誰的更動，這時候就無法自動處理了。&lt;/p&gt;
&lt;p&gt;可以搜尋「resolve git&amp;nbsp;conflict」找到相關的解決辦法。&lt;/p&gt;
&lt;h4 id="push-fail"&gt;Push&amp;nbsp;fail&lt;/h4&gt;
&lt;p&gt;這通常發在 server 上的進度點比自己本機的還要新，所以必須先把 server 上的更新同步下來。如果都是同一個 branch 的話，你可以試著用 &lt;code&gt;git pull --rebase&lt;/code&gt; 去避免額外的&amp;nbsp;merge。&lt;/p&gt;
&lt;h2 id="_4"&gt;相關資源&lt;/h2&gt;
&lt;h3 id="code-school-try-git"&gt;Code School - Try&amp;nbsp;Git&lt;/h3&gt;
&lt;p&gt;互動式練習，能懂最基本的 Git 指令操作，日常操作也主要是這些指令。並且會帶你建立一個 GitHub&amp;nbsp;帳號。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://try.github.io"&gt;https://try.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="git"&gt;Git&amp;nbsp;教學研究站&lt;/h3&gt;
&lt;p&gt;中文的介紹，他的互動式練習就是上面 Try Git&amp;nbsp;的中文化版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://dylandy.github.io/Easy-Git-Tutorial/index.html"&gt;http://dylandy.github.io/Easy-Git-Tutorial/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="code-school-git-real"&gt;Code School - Git&amp;nbsp;Real&lt;/h3&gt;
&lt;p&gt;更完整的互動式練習，如果全部的關卡都做完的話，大部份需要用 git&amp;nbsp;的狀況都練習過了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://gitreal.codeschool.com"&gt;http://gitreal.codeschool.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="learn-git-branching"&gt;Learn Git&amp;nbsp;Branching&lt;/h3&gt;
&lt;p&gt;顧名思義，是個練習操作 git branch 的線上學習網站。不過前幾個關卡在介紹 commit 相關的操作，可以試一試。真要練習可以先完成 Main 以下&amp;nbsp;levels：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Introduction&amp;nbsp;Sequence&lt;/li&gt;
&lt;li&gt;Ramping&amp;nbsp;Up&lt;/li&gt;
&lt;li&gt;Moving Work&amp;nbsp;Around&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他稍難一點，視情況跳過。但如果想學 git&amp;nbsp;比較複雜的指令可以回來看它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://pcottle.github.io/learnGitBranching/"&gt;http://pcottle.github.io/learnGitBranching/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="git-tutorial-by-atlassian"&gt;Git Tutorial by&amp;nbsp;Atlassian&lt;/h3&gt;
&lt;p&gt;蠻完整的教學，但可能稍難一點。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.atlassian.com/git/tutorials"&gt;https://www.atlassian.com/git/tutorials&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_5"&gt;學習目標&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用 Git 管理這些練習的筆記（呈接在 Text Editors&amp;nbsp;的練習）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以試著對它做一些 git 指令操作：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --oneline --graph&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立 dotfiles 和 dotvim 來管理你的環境設定檔。&lt;br&gt;
   dotfiles 就是用來儲存 &lt;code&gt;.xxx&lt;/code&gt; 的檔案們，像是 &lt;code&gt;.bashrc&lt;/code&gt; 、 &lt;code&gt;.screenrc&lt;/code&gt; 、 &lt;code&gt;.tmux.conf&lt;/code&gt; 、 &lt;code&gt;.gitconfig&lt;/code&gt; 等等，一般可能存放在 &lt;code&gt;~/.xxx&lt;/code&gt; 或 &lt;code&gt;~/.config/xxx&lt;/code&gt; 之類。用版本控制的好處是，這樣在不同的 server 之間設定可以同步。&lt;br&gt;
   dotvim 是存放 &lt;code&gt;~/.vim&lt;/code&gt; 的 Vim 設定檔。這些設定檔可以透過 soft link&amp;nbsp;連結回他們原本應該在的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意！永遠不要把 private key&amp;nbsp;放入版本控制中！&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: 搜尋 dotfiles 就會有很多範例（Ex &lt;a href="https://github.com/ccwang002/dotfiles"&gt;我的&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立自己的 Github 帳號，並把 dotfiles / dotvim repo 同步（&lt;strong&gt;push&lt;/strong&gt;）到Github。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: 建立設立好 ssh key pair 使用 ssh 上傳。Github 有&lt;a href="https://help.github.com/articles/generating-ssh-keys/"&gt;完整的教學&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:註1"&gt;
&lt;p&gt;所謂的專案目錄就是下 &lt;code&gt;git init&lt;/code&gt; 指令的目錄。&amp;#160;&lt;a class="footnote-backref" href="#fnref:註1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="zh"></category><category term="labcoding"></category></entry><entry><title>Coding 初學指南－文字編輯</title><link href="//blog.liang2.tw/posts/2016/01/lab-coding-text-editing/" rel="alternate"></link><updated>2016-01-21T22:30:00+08:00</updated><author><name>Liang2</name></author><id>tag:blog.liang2.tw,2016-01-21:posts/2016/01/lab-coding-text-editing/</id><summary type="html">&lt;p&gt;這個章節會帶大家認識一個很簡單的純文字格式 Markdown，方便大家整理筆記。同時希望大家學會一個 terminal based 的文字編輯器，方便往後在 server&amp;nbsp;環境底下的操作。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#markdown"&gt;Markdown&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#markdown_1"&gt;Markdown&amp;nbsp;語法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#text-editor"&gt;Text Editor&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#nano"&gt;Nano&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#emacs"&gt;Emacs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim"&gt;Vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim_1"&gt;Vim 相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#open-vim"&gt;Open&amp;nbsp;Vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim-ptt"&gt;學習 Vim 的心法與攻略&amp;nbsp;(ptt)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim-adventure"&gt;Vim&amp;nbsp;adventure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vim_2"&gt;Vim&amp;nbsp;本身的使用手冊&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#regex"&gt;正規表示式 Regex&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#regex_1"&gt;Regex&amp;nbsp;語法派別&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#regex-one"&gt;Regex&amp;nbsp;One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#regex-101"&gt;Regex&amp;nbsp;101&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id="markdown"&gt;Markdown&lt;/h1&gt;
&lt;p&gt;這是一個簡便的語法，它的概念是在純文字的檔案中用一些簡單的標記，就能做出大小標題、粗斜體、超連結、表格、程式碼上色等語法。&lt;/p&gt;
&lt;p&gt;如果大家了解網頁的格式 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTML"&gt;&lt;span class="caps"&gt;HTML&lt;/span&gt;&lt;/a&gt; 的話，那 markdown 的語法能直接對應到 &lt;span class="caps"&gt;HTML&lt;/span&gt; 的語法，所以這個格式在網路的世界十分流行。它的副檔名為 &lt;code&gt;.md&lt;/code&gt;，近代程式的 &lt;span class="caps"&gt;REAME&lt;/span&gt; 許多都用 markdown 寫成（例：&lt;code&gt;README.md&lt;/code&gt;）&lt;/p&gt;
&lt;h2 id="_1"&gt;相關資源&lt;/h2&gt;
&lt;h3 id="markdown_1"&gt;Markdown&amp;nbsp;語法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://markdown.tw/"&gt;http://markdown.tw/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;學習目標&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;這一系列的筆記就是用 markdown 寫成，你可以在&lt;a href="https://github.com/ccwang002/ccwang002.github.io/tree/src/content/blogs/2016-01"&gt;這裡&lt;/a&gt;找到它的原始檔。&lt;/li&gt;
&lt;li&gt;試著把 Linux 學習過的指令，或者自己常用的組合指令用 markdown&amp;nbsp;記錄。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="text-editor"&gt;Text&amp;nbsp;Editor&lt;/h1&gt;
&lt;p&gt;在 Linux 的世界很多都是純文字檔案，再加上一些規定的語法成為新的格式。前面的 markdown&amp;nbsp;就是個例子。甚至許多可以執行的程式都只是個腳本檔，能用一般的編輯器（editor）打開就能讀懂。你可以試試&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# cd is a shell script&lt;/span&gt;
nano &lt;span class="sb"&gt;`&lt;/span&gt;which &lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;       &lt;span class="c"&gt;# thanks TP&amp;#39;s idea&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常見的 editor 有：nano、vi、vim、emacs。到底什麼是最好用的文字編輯器，這是一場永無止盡的戰爭，近年來又有 Notepad++(&lt;span class="caps"&gt;GUI&lt;/span&gt;)、Sublime Text (&lt;span class="caps"&gt;GUI&lt;/span&gt;)、Neovim 的加入，這話題將不會有結論。對初學者而言，至少學會一個 editor&amp;nbsp;是必要的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;雖然一開始都說是介紹文字編輯器，但後來會開始學程式設計，所以最後大家在討論的都是「程式碼的編輯器」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當在編輯一些設定檔、程式碼時，為了避免打錯關鍵字但難以查覺，多數人會把程式碼的關鍵字上色。按照程式碼不同的屬性、功能上色之後，多數人發現能更好的理解程式的結構，因此 editor 大多帶有語法上色（syntax&amp;nbsp;highlighting）。&lt;/p&gt;
&lt;p&gt;除了語法上色，這些 editor 都有自己的設定檔規範，可以讓使用者自行修改 editor 的行為。把自己常見的編輯器改得合乎自己習慣，是長期生活在 terminal&amp;nbsp;世界的第一步，大家可以參考（抄）別人的範本開始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;讓自己的編輯器有家的感覺。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了設定檔之外，功能多的編輯器還會有「外掛」的功能，可以讓使用者增加自己的套件。這也等大家熟悉環境之後再自行玩玩吧。&lt;/p&gt;
&lt;h2 id="nano"&gt;Nano&lt;/h2&gt;
&lt;p&gt;這是一個操作簡單好懂的編輯器，&lt;del&gt;沒有語法上色&lt;/del&gt;&lt;sup id="fnref:註1"&gt;&lt;a class="footnote-ref" href="#fn:註1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。多數的系統都有內建，所以到一個新的環境時幾乎都能使用。&lt;/p&gt;
&lt;p&gt;鳥哥有教。其實直接執行它 &lt;code&gt;nano&lt;/code&gt; 它的指令都會顯示在編輯畫面中。&lt;/p&gt;
&lt;h2 id="emacs"&gt;Emacs&lt;/h2&gt;
&lt;p&gt;抱歉，我不會。但它是一個很好的編輯器。（誠徵大大補全）&lt;/p&gt;
&lt;h2 id="vim"&gt;Vim&lt;/h2&gt;
&lt;p&gt;一個老字號但維持穩定開發的編輯器。他有個特色是編輯器的模式，有些模式能編輯文字，有些不行，但能做選取、搜尋等動作。還有特有的指令合成方式（像連續技、buff&amp;nbsp;這樣）&lt;/p&gt;
&lt;p&gt;初學者通常會難以習慣，初期不熟模式、指令記不住的話會很難操作。所以建議一開始先記住最基本的指令，隨時掌握自己在的模式，日後再慢慢加深對 vim&amp;nbsp;的了解。&lt;/p&gt;
&lt;p&gt;如果真的很沒概念，鳥哥也有寫介紹。&lt;/p&gt;
&lt;h2 id="vim_1"&gt;Vim&amp;nbsp;相關資源&lt;/h2&gt;
&lt;h3 id="open-vim"&gt;Open&amp;nbsp;Vim&lt;/h3&gt;
&lt;p&gt;互動式的線上學習網站，很短，跟著操作完能會 Vim&amp;nbsp;基本動作、存檔。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.openvim.com/"&gt;http://www.openvim.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim-ptt"&gt;學習 Vim 的心法與攻略&amp;nbsp;(ptt)&lt;/h3&gt;
&lt;p&gt;了解最常用的 normal 與 insert 模式及最基本的指令。這篇的內容理解之後，就能用 vim&amp;nbsp;處理文字編輯了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.ptt.cc/bbs/Editor/M.1264056747.A.885.html"&gt;https://www.ptt.cc/bbs/Editor/M.1264056747.A.885.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim-adventure"&gt;Vim&amp;nbsp;adventure&lt;/h3&gt;
&lt;p&gt;如果很難學習 &lt;code&gt;hjkl&lt;/code&gt;、&lt;code&gt;wb&lt;/code&gt; 移動的話，這是個要用 vim&amp;nbsp;指令控制的小遊戲。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://vim-adventures.com/"&gt;http://vim-adventures.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim_2"&gt;Vim&amp;nbsp;本身的使用手冊&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;code&gt;vimtutor&lt;/code&gt; 指令，或者在 vim normal 模式時鍵入 &lt;code&gt;:help&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="_3"&gt;學習目標&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;能在 terminal 中編修一個文字檔名為 &lt;code&gt;foo.txt&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: try&amp;nbsp;nano&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nano foo.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搭配 root&amp;nbsp;權限修改系統的設定檔（你在鳥哥可能有經驗了）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: try&amp;nbsp;sudo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能在 console 中編寫程式碼。用 1.&amp;nbsp;的方案也可，但建議再試試看另外一個&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: try vi, vim or&amp;nbsp;emacs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 editor&amp;nbsp;設定讓它更符合自己的習慣。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: for vim, try editing &lt;code&gt;~/.vimrc&lt;/code&gt;; for emacs, try editing &lt;code&gt;~/.emacs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 terminal editor 使用 markdown&amp;nbsp;格式記錄這些練習的筆記與答案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="regex"&gt;正規表示式&amp;nbsp;Regex&lt;/h1&gt;
&lt;p&gt;Vim 在 normal 模式下能用 &lt;code&gt;/{pattern}&lt;/code&gt; 搜尋文中的字串。除了直接把想要查的字串寫在 pattern 裡以外，還可以設計規則找出符合 pattern 但不一樣的結果。這樣的規則稱之為正規表示式（Regular Expression, or&amp;nbsp;regex）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想做很複雜的字串比對時，都應該考慮是否能使用&amp;nbsp;regex &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要做字串比對的地方，工具通常都會提供使用 regex，例如 &lt;code&gt;grep&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt;。Vim 與 Python 也都有提供 regex&amp;nbsp;的功能。&lt;/p&gt;
&lt;h3 id="regex_1"&gt;Regex&amp;nbsp;語法派別&lt;/h3&gt;
&lt;p&gt;既然 regex 是一套字串比對的規則，就有規範它的語法。主要的 regex&amp;nbsp;語法有兩大類：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="caps"&gt;BRE&lt;/span&gt; (basic regex)&lt;ul&gt;
&lt;li&gt;Ex. &lt;code&gt;[:alnum:]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;ERE&lt;/span&gt; (extended regex) &lt;ul&gt;
&lt;li&gt;Ex. &lt;code&gt;\w&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Linux 指令當中通常會因為使用 regex 語法的不同分成多個指令&lt;sup id="fnref:註2"&gt;&lt;a class="footnote-ref" href="#fn:註2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;。例如 grep 使用 &lt;span class="caps"&gt;BRE&lt;/span&gt;；egrep 使用 &lt;span class="caps"&gt;ERE&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;與文字編輯相關的工具，像 Vim、Python、Perl&lt;sup id="fnref:註3"&gt;&lt;a class="footnote-ref" href="#fn:註3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; 也有他們各自寫 regex 的方式，但多少都與前兩大類相似，使用時都應該先查一下他們的語法。Vim 可以用 &lt;code&gt;:help regex&lt;/code&gt; 查看。&lt;/p&gt;
&lt;h2 id="_4"&gt;相關資源&lt;/h2&gt;
&lt;h3 id="regex-one"&gt;Regex&amp;nbsp;One&lt;/h3&gt;
&lt;p&gt;主要是介紹 pcre 的語法，每一個 example 多介紹一個新的語法。接著還有個 practical examples&amp;nbsp;練習整理不同的語法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://regexone.com/"&gt;http://regexone.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="regex-101"&gt;Regex&amp;nbsp;101&lt;/h3&gt;
&lt;p&gt;regex 很容易寫到自己都看不懂，這是一個幫助了解自己或別人寫好的 regex pattern&amp;nbsp;的網站。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://regex101.com/"&gt;https://regex101.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:註1"&gt;
&lt;p&gt;nano 其實有辦法做語法上色喔，詳見 &lt;a href="https://wiki.archlinux.org/index.php/Nano"&gt;Arch wiki&lt;/a&gt; 及 &lt;a href="https://github.com/scopatz/nanorc"&gt;nanorc&lt;/a&gt;。Thanks @concise&amp;#160;&lt;a class="footnote-backref" href="#fnref:註1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註2"&gt;
&lt;p&gt;哪些指令有無支援 regex 以及支援的語法可以參考 &lt;a href="https://www.debian.org/doc/manuals/debian-reference/ch01.en.html#_unix_text_tools"&gt;Debian Reference&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:註2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註3"&gt;
&lt;p&gt;Perl 的 regex 語法又稱為 &lt;strong&gt;pcre&lt;/strong&gt; style，常被其他工具使用。例如：php&amp;#160;&lt;a class="footnote-backref" href="#fnref:註3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="zh"></category><category term="labcoding"></category></entry><entry><title>Coding 初學指南－Linux</title><link href="//blog.liang2.tw/posts/2016/01/lab-coding-linux/" rel="alternate"></link><updated>2016-01-21T21:30:00+08:00</updated><author><name>Liang2</name></author><id>tag:blog.liang2.tw,2016-01-21:posts/2016/01/lab-coding-linux/</id><summary type="html">&lt;p&gt;學習使用 Linux 是第一個比較大的障礙，因為會在短時間接觸到非常多新的東西。後面的東西多少都與 Linux 相關，而 Linux 難的部份在開始使用 terminal 來操作「整台電腦」，對很習慣使用視窗介面的人會覺得很不直覺。好在近年幾個主流的 Linux Distribution 都有很好的圖形介面（正確稱 Desktop Environment），所以一開始能漸近地適應 terminal&amp;nbsp;操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在實驗室 server 上開發，「能在 terminal&amp;nbsp;裡做事情」是必須的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#linuxunixbsdnix"&gt;Linux、Unix、&lt;span class="caps"&gt;BSD&lt;/span&gt;、*nix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#distro"&gt;Distro 簡介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#redhat-centos-fedora"&gt;Redhat / CentOS /&amp;nbsp;Fedora&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#debian-ubuntu"&gt;Debian /&amp;nbsp;Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#archlinux"&gt;ArchLinux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#gnomekdexfcelxde"&gt;桌面環境 &lt;span class="caps"&gt;GNOME&lt;/span&gt;、&lt;span class="caps"&gt;KDE&lt;/span&gt;、&lt;span class="caps"&gt;XFCE&lt;/span&gt;、&lt;span class="caps"&gt;LXDE&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;相關資源&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;鳥哥的私房菜&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;各章節重點整理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#introduction-to-linux-on-edx-course"&gt;Introduction to Linux on edX&amp;nbsp;course&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#debian-user-manual"&gt;Debian User Manual&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#chapter-highlights"&gt;Chapter&amp;nbsp;Highlights&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;學習目標&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="linuxunixbsdnix"&gt;Linux、Unix、&lt;span class="caps"&gt;BSD&lt;/span&gt;、*nix&lt;/h2&gt;
&lt;p&gt;Linux 和 Unix 是不同的，但對初學者來說他們的分別不容易查覺，兩者的終端指令很相似，也因此有了 *nix 的通稱。Linux 介紹書多半會把他們的歷史好好的說一遍&lt;sup id="fnref:註2"&gt;&lt;a class="footnote-ref" href="#fn:註2" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;，有興趣聽軟體發展故事的就多留意這部份。&lt;/p&gt;
&lt;p&gt;不完整地主要分成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redhat, CentOS,&amp;nbsp;Fedora&lt;/li&gt;
&lt;li&gt;Debian, Ubuntu, Linux&amp;nbsp;Mint&lt;/li&gt;
&lt;li&gt;ArchLinux&lt;/li&gt;
&lt;li&gt;openSUSE&lt;/li&gt;
&lt;li&gt;FreeBSD,&amp;nbsp;OpenBSD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些 distributions (distros)。其實 Linux、&lt;span class="caps"&gt;BSD&lt;/span&gt; (or Unix) 的系統非常多&lt;sup id="fnref:註3"&gt;&lt;a class="footnote-ref" href="#fn:註3" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;，但對初入 Linux 的使用者，應該要找比較熱門的 distro&amp;nbsp;使用，才好找資料。&lt;/p&gt;
&lt;p&gt;上面條列的方式是有意義的，我把類似的 distro 放在同一排，只要學了其中一個，同排的其他都很好上手。其中前兩排是兩大家族反映兩種生態。我們實驗室的大 server 用的是 CentOS；但近年來我自己的電腦已經漸漸換到 Debian&amp;nbsp;上。&lt;/p&gt;
&lt;h2 id="distro"&gt;Distro&amp;nbsp;簡介&lt;/h2&gt;
&lt;p&gt;以下是我不負責任的主觀介紹。從介紹篇幅就知道我是個傾向 Debian&amp;nbsp;的人。&lt;/p&gt;
&lt;h4 id="redhat-centos-fedora"&gt;Redhat / CentOS /&amp;nbsp;Fedora&lt;/h4&gt;
&lt;p&gt;Redhat 是商用的版本，開源社群維護的對應版本是 CentOS。它以保守穩定著名，但相對來說新的東西在上面就要自己安裝，這對實驗室都用較新的工具來說是個減分的地方。他套件用 &lt;code&gt;yum xxx&lt;/code&gt; 來操作。Fedora&amp;nbsp;上的東西會新一點但我們實驗室沒人用，所以不建議。&lt;/p&gt;
&lt;h4 id="debian-ubuntu"&gt;Debian /&amp;nbsp;Ubuntu&lt;/h4&gt;
&lt;p&gt;Debian 是另一個大家族的頭，雖然是頭但一直保持穩定開發，在說明文件、&lt;a href="https://wiki.debian.org/"&gt;wiki&lt;/a&gt; 上都有不錯的品質。本身有所謂的 stable、testing、unstable 並分別對應三個版本號碼與名稱。以 2016.01 為例，stable 是 jessie(8)、testing 是 stretch(9)。unstable 永遠對應到 sid。如字面上的意思代表當中套件（軟體）的新舊程度。stable 上的工具也因此會比較舊不適合實驗室使用，但 testing 還蠻適合的，我個人很推。套件用 &lt;code&gt;apt-get xxx&lt;/code&gt; 來操作。&lt;/p&gt;
&lt;p&gt;Debian 家族中的 Ubuntu 非常火紅，網路上教學非常多，背後也有公司加持。基本上 Debian 的優點都會傳到 Ubuntu 上。Ubuntu 雖然套件包等等都從 Debian&amp;nbsp;移植，但他有自己的版本號碼，每半年發佈一個版本。&lt;/p&gt;
&lt;h4 id="archlinux"&gt;ArchLinux&lt;/h4&gt;
&lt;p&gt;再來的有興趣自己看，但我要額外介紹一個 ArchLinux。這是一個很自幹的系統，一點都不適合新手與懶人。但他有一個寫得很仔細完整的 &lt;a href="https://wiki.archlinux.org/"&gt;wiki 站&lt;/a&gt;。想要學新的套件、不會設定的話，去問 google 的時候請優先看他們的&amp;nbsp;wiki。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查資料的時候，除了 StackOverflow 、Ubuntu 論壇之外，請多看品質優良的 &lt;a href="https://wiki.archlinux.org/"&gt;Arch Linux&lt;/a&gt; 和 &lt;a href="https://wiki.debian.org/"&gt;Debian&lt;/a&gt; 的&amp;nbsp;wiki。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;寫了這麼多，沒有給一個明確的選擇，多數人還是很難決定。所以如果你是初學者，我會建議安裝 Ubuntu，在此時請選擇 &lt;a href="http://releases.ubuntu.com/15.10/"&gt;15.10&lt;/a&gt; or &lt;a href="http://releases.ubuntu.com/14.04/"&gt;14.04 &lt;span class="caps"&gt;LTS&lt;/span&gt;&lt;/a&gt; Desktop&amp;nbsp;版本，因為他網路上的資源最豐富。&lt;/p&gt;
&lt;p&gt;但我不是很喜歡 Ubuntu，所以等你有能力自己查詢 Linux 相關操作時，建議再看看別的 distro （例如我推薦的 &lt;a href="https://www.debian.org/releases/testing/"&gt;Debian testing channel&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id="gnomekdexfcelxde"&gt;桌面環境 &lt;span class="caps"&gt;GNOME&lt;/span&gt;、&lt;span class="caps"&gt;KDE&lt;/span&gt;、&lt;span class="caps"&gt;XFCE&lt;/span&gt;、&lt;span class="caps"&gt;LXDE&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;圖形化介面（&lt;span class="caps"&gt;GUI&lt;/span&gt;），除了使用者的應用程式外，還需要系統輔助、管理等核心套件。一系列的 &lt;span class="caps"&gt;GUI&lt;/span&gt;&amp;nbsp;套件就稱之為桌面環境。&lt;/p&gt;
&lt;p&gt;Windows、&lt;span class="caps"&gt;OSX&lt;/span&gt; 在安裝系統時都會自動安裝， 即桌面環境只有一種選擇。但在 Linux 上，&lt;span class="caps"&gt;GUI&lt;/span&gt; 的安裝是選擇性的，系統能在只有單純的 terminal 介面便能完整使用（例如選擇安裝 Ubuntu Server 時），不少 server&amp;nbsp;為了效能、安全性的考量都不會裝桌面環境。&lt;/p&gt;
&lt;p&gt;對 Linux 來說桌面環境是能之後再選擇安裝上去的，而且還有「不同口味」可以選擇，使用者也可以自由的移除它們（但很有可能會炸掉），常見就有 &lt;span class="caps"&gt;GNOME&lt;/span&gt;、&lt;span class="caps"&gt;KDE&lt;/span&gt;、&lt;span class="caps"&gt;XFCE&lt;/span&gt;、&lt;span class="caps"&gt;LXDE&lt;/span&gt;&lt;sup id="fnref:註4"&gt;&lt;a class="footnote-ref" href="#fn:註4" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; 幾種系統能使用。例如選擇安裝 Ubuntu Server 後，想要再加上 &lt;span class="caps"&gt;GNOME&lt;/span&gt;&amp;nbsp;列圖形化介面時，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install ubuntu-gnome-desktop
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這邊不會去細講這些實作方式的不同。簡單而言，&lt;span class="caps"&gt;GNOME&lt;/span&gt; 最流行。&lt;span class="caps"&gt;XFCE&lt;/span&gt; 使用的系統資源較少，在實驗室上的 server 常會裝這個。在 Ubuntu 上，預設是用 Unity，它是從 &lt;span class="caps"&gt;GNOME&lt;/span&gt;&amp;nbsp;沿伸出來的。&lt;/p&gt;
&lt;p&gt;第一次安裝時，就使用預設的模式吧。裝好之後要換到不同的桌面環境時，需要對套件管理系統（例&amp;nbsp;apt、yum）、調整系統設定有足夠了解。&lt;/p&gt;
&lt;h2 id="_1"&gt;相關資源&lt;/h2&gt;
&lt;p&gt;認真地說，我有點不知道 Linux&amp;nbsp;從很初學到完整學習的資源在哪裡。如果你們在學的過程中，有碰到更適合的請再告訴我（例如：留言）&lt;/p&gt;
&lt;h3 id="_2"&gt;鳥哥的私房菜&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://linux.vbird.org/linux_basic/"&gt;鳥哥官網（基礎學習篇）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.tenlong.com.tw/items/9861818510?item_id=53725"&gt;實體書連結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在台灣學 Linux 大概都會先推薦鳥哥，這應該是最多人用的完整中文資源了。如果願意啃完他，對 Linux&amp;nbsp;絕對會有足夠的認識。我大學的時候也是看這本入門的。&lt;/p&gt;
&lt;p&gt;不適合的地方是鳥哥介紹 Redhat 系的操作，很多設定在 Ubuntu 上不需要或者是用別的方式去管理。例如，在 CentOS 上可能都用文字檔來修改設定，但在 Ubuntu 上可以用 &lt;code&gt;dpkg-reconfigure&lt;/code&gt; 指令來更動。他示範的 &lt;span class="caps"&gt;OS&lt;/span&gt; 為 CentOS 5.x，現在 CentOS 已經 7.x&amp;nbsp;版了，許多設定也過時了，新的工具不會介紹到。&lt;/p&gt;
&lt;p&gt;例如現在安裝 Linux 時，在磁區分割上都有很好的預設值，初學者可以不用再學調整 swap 等設定。同時系統也都提供使用 &lt;span class="caps"&gt;LVM&lt;/span&gt; (Logical Volume Manager) &lt;sup id="fnref:註5"&gt;&lt;a class="footnote-ref" href="#fn:註5" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt; 管理磁區，這些磁區 (&lt;span class="caps"&gt;LV&lt;/span&gt;) 日後能動態調整。換句話說，第五章（含）的內容都與現在使用 Linux 的方式不同，如果只是順著鳥哥書的順序一章一章看下來，會沒辦法對照自己系統操作，因為近期的 Linux&amp;nbsp;安裝只要很順的下一步就能完成了。&lt;/p&gt;
&lt;h4 id="_3"&gt;各章節重點整理&lt;/h4&gt;
&lt;p&gt;鳥哥的內容退一千步來說都對初學者很有幫助，但為了避免各位花費無謂的時間在「對照古早與現代操作 (google&amp;nbsp;到的資料)上」，整理個表格讓大家知道每個章節什麼地方需要看。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;章節&lt;/th&gt;
&lt;th align="left"&gt;章節名&lt;/th&gt;
&lt;th&gt;重要的內容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="left"&gt;計算機概論&lt;/td&gt;
&lt;td&gt;沒聽過 &lt;span class="caps"&gt;CPU&lt;/span&gt;、&lt;span class="caps"&gt;RAM&lt;/span&gt;、&lt;span class="caps"&gt;MB&lt;/span&gt; &lt;span class="caps"&gt;GB&lt;/span&gt; 單位就從頭看； 不然就讀資料表示方式(3)、軟體程式運作(4)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;5&lt;/td&gt;
&lt;td align="left"&gt;首次登入與線上求助 man page&lt;/td&gt;
&lt;td&gt;文字模式下指令的下達(2)、man page 與 info page(3)、nano(4)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;6&lt;/td&gt;
&lt;td align="left"&gt;Linux 的檔案權限與目錄配置&lt;/td&gt;
&lt;td&gt;全&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;7&lt;/td&gt;
&lt;td align="left"&gt;Linux 檔案與目錄管理&lt;/td&gt;
&lt;td&gt;除檔案隱藏與特殊屬性(4)外都重要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;8&lt;/td&gt;
&lt;td align="left"&gt;Linux 磁碟與檔案系統管理&lt;/td&gt;
&lt;td&gt;檔案系統的簡單操作(2)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;9&lt;/td&gt;
&lt;td align="left"&gt;檔案與檔案系統的壓縮與打包&lt;/td&gt;
&lt;td&gt;壓縮檔案的用途與技術(1)、打包指令(3)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;10&lt;sup id="fnref:*"&gt;&lt;a class="footnote-ref" href="#fn:*" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td align="left"&gt;vim 程式編輯器&lt;/td&gt;
&lt;td&gt;語系編碼轉換(4.3)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;11&lt;/td&gt;
&lt;td align="left"&gt;認識與學習 &lt;span class="caps"&gt;BASH&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;全。但可視情況忽略 2.4-2.8、6.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;12&lt;sup id="fnref:†"&gt;&lt;a class="footnote-ref" href="#fn:†" rel="footnote"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td align="left"&gt;正規表示法與文件格式化處理&lt;/td&gt;
&lt;td&gt;前言(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;13&lt;/td&gt;
&lt;td align="left"&gt;學習 Shell Scripts&lt;/td&gt;
&lt;td&gt;全（等用到再看）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;22&lt;/td&gt;
&lt;td align="left"&gt;軟體安裝：原始碼與 Tarball&lt;/td&gt;
&lt;td&gt;全（了解流程、懂有這些關鍵字就好）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;23&lt;/td&gt;
&lt;td align="left"&gt;軟體安裝： &lt;span class="caps"&gt;RPM&lt;/span&gt;, &lt;span class="caps"&gt;SRPM&lt;/span&gt; 與 &lt;span class="caps"&gt;YUM&lt;/span&gt; 功能&lt;/td&gt;
&lt;td&gt;Ubuntu 用的是 &lt;span class="caps"&gt;APT&lt;/span&gt;&lt;sup id="fnref:‡"&gt;&lt;a class="footnote-ref" href="#fn:‡" rel="footnote"&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="introduction-to-linux-on-edx-course"&gt;Introduction to Linux on edX&amp;nbsp;course&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.edx.org/course/introduction-linux-linuxfoundationx-lfs101x-2"&gt;課程連結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux Foundation 所開辦的線上課程，有英文的影片和講義。還請到了 Linux Kernel 的作者 Linus Torvalds&amp;nbsp;來拍介紹片。這是真的從非常基礎開始講，我有稍微看過，但我怕難度不夠，需要再搭配其他的資源來使用。好處是初期的學習比讀鳥哥前幾章來的快非常多（鳥哥前幾章為計算機概論）。&lt;/p&gt;
&lt;h3 id="debian-user-manual"&gt;Debian User&amp;nbsp;Manual&lt;/h3&gt;
&lt;p&gt;英文的 Debian 系統使用者手冊，裡面包含了常見問題排解、各種硬體上的安裝指南、參考手冊。想要好好學習現代 Debian (Linux)&amp;nbsp;的使用方式的話，可以參考這些資源，它們還有再維護。&lt;/p&gt;
&lt;p&gt;缺點是這手冊太長了，如果有碰到什麼特別想了深入了解的，建議可以看這個。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.debian.org/doc/user-manuals"&gt;https://www.debian.org/doc/user-manuals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.debian.org/doc/manuals/debian-reference/index.en.html"&gt;Debain Reference&lt;/a&gt; (online &lt;span class="caps"&gt;HTML&lt;/span&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="chapter-highlights"&gt;Chapter&amp;nbsp;Highlights&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Chp. No&lt;/th&gt;
&lt;th align="left"&gt;Chp. Name&lt;/th&gt;
&lt;th align="left"&gt;Highlights&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;1&lt;/td&gt;
&lt;td align="left"&gt;&lt;span class="caps"&gt;GNU&lt;/span&gt;/Linux tutorials&lt;/td&gt;
&lt;td align="left"&gt;Everything except for 1.3 Midnight Commander&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;2&lt;/td&gt;
&lt;td align="left"&gt;Debian package management&lt;/td&gt;
&lt;td align="left"&gt;Read 2.2 Basic package management operations&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;10&lt;/td&gt;
&lt;td align="left"&gt;Data management&lt;/td&gt;
&lt;td align="left"&gt;Read 10.1 Sharing, copying, and archiving&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_4"&gt;學習目標&lt;/h2&gt;
&lt;p&gt;因為這邊指的 Linux 算是一個蠻廣的內容，一開始學的時候很容易迷失方向。所以我額外列了幾個很重要的觀念，你應該能在學習 Linux&amp;nbsp;的初期接觸到他們：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解 &lt;code&gt;$PATH&lt;/code&gt; 與程式執行位置的關係&lt;ul&gt;
&lt;li&gt;為什麼打 &lt;code&gt;ls&lt;/code&gt; 可以找到這隻名為 &lt;code&gt;ls&lt;/code&gt; 的程式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;知道 stdin、stdout、stderr；pipeline&amp;nbsp;的使用&lt;/li&gt;
&lt;li&gt;知道環境變數是什麼，怎麼修改&lt;/li&gt;
&lt;li&gt;了解檔案、目錄、相對路徑；權限設定&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;&amp;lt;cmd&amp;gt; -h&lt;/code&gt; &lt;code&gt;&amp;lt;cmd&amp;gt; --help&lt;/code&gt; &lt;code&gt;man &amp;lt;cmd&amp;gt;&lt;/code&gt; 來查看指令的功能、可下的參數&lt;ul&gt;
&lt;li&gt;&amp;lt;cmd&gt; = 任何在 linux&amp;nbsp;下的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你花了一個禮拜的時間，但上述的內容連聽都沒聽過（或沒什麼使用到），那很可能你學習 Linux&amp;nbsp;的方式跟我想得很不一樣，請先寫個信告訴我。上面這些觀念的學習也是漸近式的，過了一個禮拜只有聽過但不是很了解，這是很正常的現象。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己從零開始安裝一次 Linux 系統（可以用 &lt;span class="caps"&gt;VM&lt;/span&gt;）。&lt;/li&gt;
&lt;li&gt;定期使用它一個星期以上（即熟悉 &lt;code&gt;cd&lt;/code&gt; &lt;code&gt;ls&lt;/code&gt; 等基礎指令）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 ssh 連線到遠端的 Linux。（要打開 ssh 的&amp;nbsp;port）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bonus: 在 ssh&amp;nbsp;連線時不用打密碼。  &lt;/li&gt;
&lt;li&gt;Bonus hint: 查 &lt;code&gt;authorized_keys&lt;/code&gt;。會需要建立 ssh user identity keypair，這會在上傳 GitHub&amp;nbsp;時用到）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝一個叫 &lt;a href="http://hisham.hm/htop/"&gt;htop&lt;/a&gt;&amp;nbsp;的系統監控軟體。使用它來查看系統資料的使用狀況&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bonus:&lt;ul&gt;
&lt;li&gt;調整欄位的排版&lt;/li&gt;
&lt;li&gt;開啟 Tree&amp;nbsp;Veiw&lt;/li&gt;
&lt;li&gt;選擇顯示單一使用者運行的程序（太舊的 htop&amp;nbsp;可能沒這功能）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝一個叫 &lt;a href="http://aria2.sourceforge.net/"&gt;aria2&lt;/a&gt; 的續傳軟體，他可以多線程下載 &lt;span class="caps"&gt;HTTP&lt;/span&gt;(S)、&lt;span class="caps"&gt;FTP&lt;/span&gt;、甚至 &lt;span class="caps"&gt;BT&lt;/span&gt;。今天想要下載 Debian Jessie netinst 的映像檔，使用 2&amp;nbsp;個線程同時下載。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: 查 &lt;code&gt;aria2c&lt;/code&gt; 的 man&amp;nbsp;page。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;學會查看系統硬碟的使用量；查看當前目錄內所有檔案的大小（絕對不是 &lt;code&gt;ls -l&lt;/code&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: &lt;code&gt;df&lt;/code&gt; 和 &lt;code&gt;du&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scp 是個透過 ssh 傳送一或多個檔案的指令，試著用它把自己電腦的檔案（們）傳到 server&amp;nbsp;上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bonus:&lt;ul&gt;
&lt;li&gt;在路徑中搭配特殊字元 &lt;code&gt;*?&lt;/code&gt; 傳多個檔案&lt;/li&gt;
&lt;li&gt;有一個更精密的傳檔工具叫&amp;nbsp;rsync，試著改用它來傳檔。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;span class="caps"&gt;GUI&lt;/span&gt; 的遠端介面。這相關的技術有很多：&lt;span class="caps"&gt;VNC&lt;/span&gt;、&lt;span class="caps"&gt;RDP&lt;/span&gt; 最常見。&lt;span class="caps"&gt;RDP&lt;/span&gt; 在 windows 連接上比較順暢；&lt;span class="caps"&gt;VNC&lt;/span&gt; 在畫面傳輸比較沒效率，這會對 server 造成不小的負擔，也很容易 lag。有一個新的通訊協定叫 &lt;span class="caps"&gt;NX&lt;/span&gt;，它對畫面壓縮使用即便網速很慢依然能使用圖形介紹。&lt;br&gt;
   試著用實作 &lt;span class="caps"&gt;NX&lt;/span&gt; 協定的軟體 X2go 做遠端桌面連線到&amp;nbsp;server。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hint: 你需要在 server 與 client 端（通常是自己的電腦）都裝上 X2go 的軟體，並會使用到 &lt;span class="caps"&gt;SSH&lt;/span&gt;&amp;nbsp;的連線設定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只用 Linux&amp;nbsp;生存一個星期以上（包含中文輸入、上網等等）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:註2"&gt;
&lt;p&gt;Linux distros 源流 &lt;a href="http://en.wikipedia.org/wiki/Linux_distribution"&gt;http://en.wikipedia.org/wiki/Linux_distribution&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:註2" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註3"&gt;
&lt;p&gt;&lt;a href="http://distrowatch.com/"&gt;Distro Watch&lt;/a&gt; 是一個介紹各種 Linux、&lt;span class="caps"&gt;BSD&lt;/span&gt; 系統的地方，可以來這邊看各個 distro 的介紹。&amp;#160;&lt;a class="footnote-backref" href="#fnref:註3" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註4"&gt;
&lt;p&gt;&lt;span class="caps"&gt;LXDE&lt;/span&gt; 原作者是 PCMan 喔，也有相當多的台灣人在維護它。&amp;#160;&lt;a class="footnote-backref" href="#fnref:註4" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:註5"&gt;
&lt;p&gt;&lt;span class="caps"&gt;LVM&lt;/span&gt; 不懂沒關係，有興趣可以參考&lt;a href="http://linux.vbird.org/linux_basic/0420quota.php#lvm"&gt;鳥哥十五章&lt;/a&gt;、&lt;a href="https://wiki.archlinux.org/index.php/LVM"&gt;Arch Wiki&lt;/a&gt; 介紹&amp;#160;&lt;a class="footnote-backref" href="#fnref:註5" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:*"&gt;
&lt;p&gt;學 vim 有別的資源，詳見 &lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;2 Text Editing&lt;/a&gt;。&lt;br&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:*" rev="footnote" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:†"&gt;
&lt;p&gt;正規表示（regex）很重要，但初學 Linux 時會覺得很複雜可以跳過。 &lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;2 Text Editing&lt;/a&gt; 會再接觸到一次 vim 的 regex、&lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;4 Python&lt;/a&gt; 也會學到 Python 的 regex，可以等到時候再回來學 &lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;egrep&lt;/code&gt; 等指令。&lt;br&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:†" rev="footnote" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:‡"&gt;
&lt;p&gt;&lt;span class="caps"&gt;APT&lt;/span&gt; 的使用教學可以參考 &lt;a href="https://help.ubuntu.com/community/AptGet/Howto"&gt;Ubuntu 官網&lt;/a&gt;、&lt;a href="http://blog.longwin.com.tw/2005/05/use_apt/"&gt;網路上大大的筆記&lt;/a&gt;。&amp;#160;&lt;a class="footnote-backref" href="#fnref:‡" rev="footnote" title="Jump back to footnote 7 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="zh"></category><category term="labcoding"></category></entry><entry><title>Coding 初學指南－總章</title><link href="//blog.liang2.tw/posts/2016/01/lab-coding-intro/" rel="alternate"></link><updated>2016-01-21T21:00:00+08:00</updated><author><name>Liang2</name></author><id>tag:blog.liang2.tw,2016-01-21:posts/2016/01/lab-coding-intro/</id><summary type="html">&lt;p&gt;Last Edited: Jan,&amp;nbsp;2016&lt;/p&gt;
&lt;p&gt;（如果內容有誤，你可以留言，或用任何管道告訴我）&lt;/p&gt;
&lt;p&gt;雖然實驗室不是正規寫程式的地方，多數的人也沒把寫程式當成一回事。不過隨著要分析的資料、樣本數越來越多，多到自己電腦跑不動，server 也要跑很久的時候，就會顯示出程式的重要性。另一方面，現在的研究講求 &lt;em&gt;reproducibility&lt;/em&gt;，如果要讓自己的分析在一年之後也能重現，或者讓世界上其他的研究者也能重現的話，需要基本的程式技巧。&lt;/p&gt;
&lt;p&gt;這一系列的文章，目標讓實驗室的新生，不論是不是 &lt;span class="caps"&gt;CS&lt;/span&gt;&amp;nbsp;背景，都能了解當今軟體開發流程及基本技能。軟體開發需要一些背景知識，才能與開發者正常交流。這些背景知識包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;熟悉在 server 上工作（或 Linux&amp;nbsp;的使用）&lt;/li&gt;
&lt;li&gt;一個很多人用的軟體工具長什麼樣&lt;/li&gt;
&lt;li&gt;如何把自己的程式與別人分享&lt;/li&gt;
&lt;li&gt;多人共同開發&lt;/li&gt;
&lt;li&gt;其他人都怎麼樣寫程式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些內容在學校課程的訓練中較少，尤其是電機背景的話在寫程式又更為隨性，但這對一個長期的軟體專案是必需的。希望大家能養成這些習慣。&lt;/p&gt;
&lt;p&gt;這些主題需要熟練到什麼程度，見人見智，深入下去每一個都夠花幾個月的時間鑽研，但以一個實驗室專題、或要完成的軟體專案來說都不實際，至少老闆一點都不在意。所以個人覺得，最低標準就是在遇到該課題不懂的地方時，「能知道怎麼下關鍵字查」且「查完的結果能看得懂」。&lt;/p&gt;
&lt;p&gt;系列文原本放在 &lt;a href="https://gist.github.com/ccwang002/368025d3c541ed983892"&gt;Github Gist&lt;/a&gt; 上，但現在有自己的 blog&amp;nbsp;了，就整理到這邊順便更新。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;學習方式&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;問：為什麼不帶大家手把手教學？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;熟練來自生活中的實踐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#windows"&gt;給 Windows&amp;nbsp;使用者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#osx"&gt;給 &lt;span class="caps"&gt;OSX&lt;/span&gt;&amp;nbsp;使用者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;文章目錄&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;學習方式&lt;/h3&gt;
&lt;p&gt;每一篇都會是一個主題，主題底下會列出一些資源。主題的最後有學習目標，方便讓你評估自己學到什麼程度。學習目標會給一個明確的任務，我盡量讓它能跟（宅宅的）日常生活結合。通常只要完成前一、二個目標就行了，這也不是功課所以不用給我看。但如果你不介意給我看的話，我會分享我主觀的建議。大部份的任務是沒有唯一的正確答案，只要能解決問題都是好方法。&lt;/p&gt;
&lt;p&gt;總之，這些資源不用全看，任務不用全做，大家自己斟酌要花多少時間在不同的主題上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;挑你喜歡的東西盡量鑽，沒有 fu&amp;nbsp;的就隨便看看會了就好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我會盡量按照難易度排列，中英文的資源都放。&lt;/p&gt;
&lt;h4 id="_2"&gt;問：為什麼不帶大家手把手教學？&lt;/h4&gt;
&lt;p&gt;簡單地說沒空。認真地說，大家的學習速度跟底子都不一樣，同步學只是浪費各位的時間。&lt;/p&gt;
&lt;p&gt;我大概沒有辦法一個一個項目帶大家練習，底下的很多連結只是提供一個學習的窗口，真正要學下去，都是要花一定時間的。所以也不要抱著「只要讀完這些文章就會了○○○」這樣的想法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;白話的來說，這些背景知識就像遊戲的技能樹，基礎技能要先點好才能點進階技能。要把基礎技能點滿了再練等也可能，但不必要一直練等，大家未必喜歡，現實中也不許你練等不解任務。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一開始可能碰到小問題就要查，或者要連續查很多個網頁被導向四、五次才能稍微解答自己的疑問。這個現象是非常正常的，如果大家能撐過初期這段比較挫折的時期，日後要自學軟體基本上就沒問題了。&lt;/p&gt;
&lt;h3 id="_3"&gt;熟練來自生活中的實踐&lt;/h3&gt;
&lt;p&gt;要很快地學好程式，我推薦練習把程式應用在生活中。例如用文字命令列來下載檔案；把自己筆電變成 linux&amp;nbsp;桌面系統，練習自己編譯軟體、解決各式安裝的狀況。讓自己的電腦成為一個自己能接受的軟體開發環境，並經常的使用它，就能降低對寫程式的陌生與不知所措感。&lt;/p&gt;
&lt;p&gt;上面的方法可能稍難一些，負擔比較小的可以開始做「思考練習」。思考練習包含去想生活中的大小事該怎麼寫程式來控制。例如我該怎麼設計一個電梯系統？臉書怎麼呈現大家的動態？只要大概想一想就好了，想不出來也不會怎樣，也不用特別查資料。過一段時間對程式的 sense&amp;nbsp;也會提昇。&lt;/p&gt;
&lt;p&gt;如果需要更硬派的學習方式，不妨把自己電腦安裝的軟體的源始碼都拿出來看一下，加入幾個自己平常用的軟體的專案來修改它，讓它更少問題更多功能（一般叫 contribute）。也可以把實驗室有用到的工具的原始碼拿出來看一下，例如&amp;nbsp;sratoolkit、cutadapt，看看自己能不能讀懂別人的程式碼。&lt;/p&gt;
&lt;h3 id="windows"&gt;給 Windows&amp;nbsp;使用者&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;建議大家想辦法裝個 Linux（或用 Mac）。如果不想取代掉自己的 Windows 環境話，可以安裝 VirtualBox 裝個虛擬的 Linux，或者在 Amazon 等 &lt;span class="caps"&gt;VPS&lt;/span&gt;&amp;nbsp;架一台虛擬主機。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Windows 因為對圖形介面（&lt;span class="caps"&gt;GUI&lt;/span&gt;）設計的很好，也不容易讓使用者用命令列模式（terminal, console)。雖然 Windows 上有像 command prompt、Powershell 之類的環境，但都很難用它來操控整個系統。而且它打從骨子就跟 Linux 不一樣，所以相關的指令不好在網上的教學文章中找到，而多數 Windows 的開發者也不喜歡用&amp;nbsp;terminal。&lt;/p&gt;
&lt;p&gt;另一方面，大家對 Visual Studio 的印象都是要收錢的&lt;sup id="fnref:註1"&gt;&lt;a class="footnote-ref" href="#fn:註1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;，這是 Windows 上最完整最好用的開發環境，不想付費的情況下可能就會覺得「寫程式充滿障礙」，更何況 &lt;span class="caps"&gt;VS&lt;/span&gt; 也是圖形化的編輯器，也會不了解背後運作的方式。市面的開源軟體多半在 *nix 上開發，對 Windows&amp;nbsp;支援度差也加深這個障礙（「想要自己裝但都一堆限制又很容易失敗」）&lt;/p&gt;
&lt;p&gt;不用 terminal 的壞處是很難想像自己系統中的軟體為什麼能運作。感覺要寫個有 &lt;span class="caps"&gt;GUI&lt;/span&gt;&amp;nbsp;的程式都要很厲害，跟自己學過的寫程式都不一樣。但實質上是沒有太多區別的，只是要完成一個能安裝在系統中的視窗軟體，需要的步驟多很多，一般簡單的專案都不會到那個階段。&lt;/p&gt;
&lt;h3 id="osx"&gt;給 &lt;span class="caps"&gt;OSX&lt;/span&gt;&amp;nbsp;使用者&lt;/h3&gt;
&lt;p&gt;Mac &lt;span class="caps"&gt;OSX&lt;/span&gt; 使用者也有這樣的現象，但因為 &lt;span class="caps"&gt;OSX&lt;/span&gt; 在底層用的是跟 FreeBSD 很相似，而 FreeBSD 跟 Linux 相似，所以它的 terminal 環境是很完整的。現在軟體開發者很多人用 &lt;span class="caps"&gt;OSX&lt;/span&gt;，因此網路上 Linux、&lt;span class="caps"&gt;OSX&lt;/span&gt;&amp;nbsp;資源都很多，兩者的經驗常能自然地移植。&lt;/p&gt;
&lt;p&gt;如何在 &lt;span class="caps"&gt;OSX&lt;/span&gt; 上開發程式，可以參考&lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;附錄 0&lt;/a&gt;&amp;nbsp;的筆記，但內容很主觀，不是每個人都會像我這樣用。&lt;/p&gt;
&lt;h2 id="_4"&gt;文章目錄&lt;/h2&gt;
&lt;p&gt;寫一寫內容也變得蠻多的，所以把它切成了幾篇文章，請按照數字順序閱讀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-linux/"&gt;1&amp;nbsp;Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-text-editing/"&gt;2 Text Editing (Markdown, Text&amp;nbsp;Editor)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-version-control/"&gt;3 Version Control&amp;nbsp;(Git)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-python/"&gt;4&amp;nbsp;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-appendix-osx-env/"&gt;A0 &lt;span class="caps"&gt;OSX&lt;/span&gt; Development&amp;nbsp;Environment&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="//blog.liang2.tw/posts/2016/01/lab-coding-appendix-bioinfo-python/"&gt;A1 Python in&amp;nbsp;Bioinformatics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，用 &lt;a href="/tag/labcoding.html"&gt;labcoding&lt;/a&gt; 這個 tag&amp;nbsp;也可以找到所有的文章。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:註1"&gt;
&lt;p&gt;Visual Studio 自 2013 後有 &lt;a href="https://www.visualstudio.com/en-us/news/vs2013-community-vs.aspx"&gt;Community&lt;/a&gt; 版本，免費但內容與 Professional 版本大致無異，所以未來要有 C/C++ 32/64bit Compiler 會更容易。但多數的開源軟體還沒跟進，所以很多還在用舊的 &lt;span class="caps"&gt;VS&lt;/span&gt; 版本（就要付費），這個現象還會持續一陣。學校都有買。&amp;#160;&lt;a class="footnote-backref" href="#fnref:註1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="zh"></category><category term="labcoding"></category></entry></feed>